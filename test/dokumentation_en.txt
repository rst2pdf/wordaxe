= wordaxe Hyphenation =

Henning von Bargen, 14.09.2008, Release 0.2.7 pre

== Overview ==

The wordaxe library was formerly called "deco-cow", which is
an abbreviation for "decomposition of compound words".

The library consists of three program parts:

1) an (easily extendable) class library adding hyphenation support
   to Python programs.

2) a special hyphenation algorithm, based on the decomposition of
   compound words (the implementation is only for the German language).

3) a hyphenation extension for the <a href="http://www.reportlab.org">ReportLab</a> PDF library.

== <a name="bezug" />Where to get it ==

The wordaxe library is hosted at SourceForge (<a href="http://deco-cow.sourceforge.net">http://deco-cow.sourceforge.net</a>).

The current stable Release of the software can be downloaded from the
SourceForge <a href="http://sourceforge.net/project/showfiles.php?group_id=105867">download page</a>.
There's also a subversion repository where you can get the current development code.

== Licence ==

The wordaxe hyphenation library is dual-licensed.
You are permitted to use and distribute wordaxe under one 
of these open source licenses:

"Apache 2.0 License" or "2-Clauses BSD-License".

For details, see the file license.txt contained in the library.

Regarding the licenes for the 
<a href="http://hkn.eecs.berkeley.edu/~dyoo/pyHnj">pyHnj library</a> from Danny Yoo
(HNJ hyphenation, contained in the wordaxe installation), for the 
<a href="http://www.reportlab.org">ReportLab PDF library</a> 
and the <a href="http://code.google.com/p/pyhyphen">pyhyphen library</a>
please visit the corresponding web sites.

The dictionary files with the suffix <tt>.dic</tt> have been taken from
the OpenOffice distribution, they are licences under the GNU LGPL.

== Installation ==

=== ReportLab 2.1 or 2.2 ===

wordaxe Release 0.2.6 has been tested with Python 2.5 and ReportLab 2.2,
but it should work equally well with Python 2.4 funktionieren, since AFAIK
none of the new features of 2.5 have are used.

ReportLab 2.2 can be obtained from <a href="http://www.reportlab.org">www.reportlab.org</a>.
The installation is easy (though not with easy-install ;-) and is not described here.

wordaxe works with ReportLab 2.1, too.

Notes on even older ReportLab versions:

Though untested, wordaxe Release 0.2.6 may work with ReportLab 2.0.
Otherwise you can use 0.2.2 in this case,
but the installation is a little harder (because some more files
in the ReportLab installation had to be overwritten and the installation guide
was not correct).

For ReportLab 1.19 please use Release 0.1.1 (not recommended).
When upgrading from ReportLab 1.x to 2.x you probably have to change
existing code (independently from wordaxe), since for 2.x all paragraph
input text has to be unicode or UTF8 encoded.

=== Installating wordaxe step-by-step ===
1. Download the ZIP archive wordaxe-0.2.6.zip from the SourceForge site.

2. Unpack the ZIP-archive wordaxe-0.2.6.zip in the root directory C:\
   (inside the archive, all files are in a directory "wordaxe-0.2.6").
   
   The following directory structure will be created:

{{{
C:
    wordaxe-0.2.6
        htdocs
            css
            examples
            icons
            images
         wordaxe
            dict
            rl
}}}

   
3a. On the command line, execute:

{{{
cd /d c:\wordaxe-0.2.6
setup.py install
}}}

3b. Alternative:

   Make a backup copy of the file reportlab\pdfbase\rl_codecs.py from the
   ReportLab Installation; then replace the file with the
   modified version from c:\wordaxe-0.2.6\wordaxe\rl\rl_codecs.py.
   
   <em>Note:</em> This will only change two lines of code in the file, 
   responsible for the "shy hyphen" character SHY. 
   
   Add the new library to the Python path, for example by creating a
   file wordaxe.pth in c:\python25\lib\site-packages,
   containg only one text line:

{{{
c:\wordaxe-0.2.6
}}}

4. Assure that "import wordaxe" doesn't create an error message.
   
5. ReportLab will work as before; differences may only occur,
   if <em>your own</em> programs or texts use the SHY-character.
   
== Usage ==

To see the hyphenation with the DCW-Algorithmus (Decomposition of compound words)
in action for german language text,
run the example script "test_hyphenation.py" in the test subdirectory.
It will produce two PDF files, test_hyphenation-plain.pdf and test_hyphenation_styled.pdf.

The document you read now has also be produced with automatic hyphenation
(see the buildDoku.py script).

To add hyphenation support to your own programs (here using the DCW algorithm
as an example), only very few modifications in your code are necessary:
  
Add the following lines:

{{{
from wordaxe import hyphRegistry
from wordaxe.DCWHyphenator import DCWHyphenator
hyphRegistry['DE'] = DCWHyphenator('de',5)
}}}

Search and replace the following strings:
{{{
Search                            Replace with
reportlab.platypus.paragraph      wordaxe.rl.paragraph
reportlab.platypus.xpreformatted  wordaxe.rl.xpreformatted
reportlab.lib.styles              wordaxe.rl.styles
}}}

Enable hyphenation. To do this, set two attributes in your ParagraphStyle:

{{{
stylesheet = getSampleStyleSheet()
myStyle = stylesheet["BodyText"]
myStyle.language = 'DE'
myStyle.hyphenation = True
}}}

=== Using a Hyphenator ===

Of course the wordaxe hyphenation can be used independent from ReportLab.

In the constructor, at least a language code and a minimal word-length
have to be supplied. Shorter words will not be considered for hyphenation.

{{{
from wordaxe.DCWHyphenator import DCWHyphenator
hyphenator = DCWHyphenator('de',5)
}}}

Now you can hyphenate (unicode) words.
The return value will either be None (unknown word)
or a HyphenatedWord, that is, a word with hyphenation points and their quality.

{{{
hword = hyphenator.hyphenate(u"Donaudampfschiffahrt")
print "Possible hyphenations", hword.hyphenations
# Split the word at the second possible hyphenation point:
left,right = hword.split(hword.hyphenations[1])
# returns: (u'Donau\xad', HyphenatedWord(u'dampfschiffahrt'))
# The left part is a unicode object (here: Donau-),
# the right part is the rest of the word (a HyphenatedWord instance again),
# that should go into the next line.
print left
print right
print right.hyphenations
}}}

== Hyphenation Classes ==

TODO continue translation

Zur Verwendung der Klassen siehe auch die jeweiligen Quelltexte, die
jeweils Testcode mit Aufruf des Konstruktors enthalten. Der Testcode
kann aufgerufen werden, um zu sehen, wie die jeweilige Klasse mit
Worten umgeht. Die Worte können auf der Kommandozeile eingegeben werden.
Es bietet sich an, dabei außerdem die Option -v anzugeben.

Beispiel:
{{{
c:\python25\python wordaxe\DCWHyphenator.py -v Silbentrennung
}}}

=== DCWHyphenator ===

Diese Klasse basiert auf der Zerlegung von zusammengesetzten Wörtern,
inspiriert durch die Publikationen der TU Wien zur "sicheren sinnentsprechenden 
Silbentrennung für die deutsche Sprache", siehe 
<a href="http://www.ads.tuwien.ac.at/research/SiSiSi/">http://www.ads.tuwien.ac.at/research/SiSiSi/</a>.

Die Implementierung hat jedoch nichts zu tun mit dem Closed Source Produkt "SiSiSi".

Der Algorithmus funktioniert wie folgt:
Ein gegegebenes zusammengesetztes Wort wird zunächst in die Einzelwörter zerlegt.

Dazu wird die Datei DE_hyph.ini verwendet.
Sie enthält Wortstämme, teilweise versehen mit zusätzlichen Annotationen wie
NEED_SUFFIX, NO_SUFFIX etc.
Außerdem sind dort mögliche Vorsilben und Suffixe hinterlegt.

Aufgrund der Komplexität des Zerlegungsverfahrens ist es vergleichsweise langsam:

Das Wort wird von links nach rechts betrachtet.
Es wird zerlegt in ein Tupel (L,R), wobei natürlich verschiedene
Aufteilungen möglich sind, z.B. bei "Trennung" ("T", "rennung"),
("Tr", "ennung"), ("Tre", "nnung"),  usw.
Immer wird geprüft, ob der linke Teil zu einer der bekannten Vorsilben, Wortstämme 
bzw. Endungen aus der Datei DE_hyph.ini passt. Falls ja, wird mit dem Restwort
analog weitergemacht. Andernfalls, oder wenn die Kombination keinen Sinn ergibt
(z.B. Vorsilbe + Suffix ohne Wortstamm dazwischen) wird abgebrochen.

Im Prinzip handelt es sich dabei um ein rekursives Verfahren, was aber im
Programm nicht rekursiv, sondern mit Hilfe von Listen umgesetzt wurde.

Die besonderen Eigenschaften dieses Verfahrens sind:

Es werden nur dem Programm bekannte Wortstämme erkannt. 

Dadurch werden mögliche Trennstellen evtl. übersehen, denn unbekannte Wörter werden 
grundsätzlich nicht getrennt. 

Andererseits kann es so auch nicht zu falschen Trennungen kommen.

Wenn ein zusammengesetztes Wort auf mehr als eine Art interpretiert werden kann,
werden nur die Trennstellen berücksichtigt, die bei allen Zerlegungen gleich sind.
Dadurch kann es nicht zu sinnentstellenden Trennungen kommen.

Trennstellen werden mit einer Priorität versehen, die dann vom aufrufenden Programm
berücksichtigt werden kann, um gute Trennstellen (an Wortgrenzen) zu bevorzugen.

=== ExplicitHyphenator ===

Bei dieser Klasse kann man für jedes Wort einzeln vorgeben, wie es getrennt werden
soll. Damit eignet sich diese Klasse allenfalls für bestimmte Anwendungsbereiche,
bei denen der Wortschatz so klein ist, dass die Trennung für alle anfallenden Worte
(zumindest die langen) vorab festgelegt werden kann (z.B. wenn praktisch nur feste
Textbausteine verwendet werden).

=== PyHnjHyphenator ===

Diese Klasse funktioniert so wie die Silbentrennung in TeX, basierend auf Mustern
(vergleiche libhnj, pyhnj). Die Implementierung kann die pyhnj C-Bibliothek
verwenden (das ist die Voreinstellung) oder aber Pure Python, wenn das
Argument purePython=True beim Konstruktor angegeben wird.

=== wordaxe.plugins.PyHyphenHyphenator ===

Diese Klasse funktioniert ebenfalls so ähnlich wie in TeX, verwendet jedoch
eine andere Implementierung und <em>funktioniert wesentlich besser</em>!
Um diese Klasse verwenden zu können, muss die pyhyphen-Bibliothek
installiert sein (siehe <a href="http://pypi.python.org/pypi/PyHyphen/">http://pypi.python.org/pypi/PyHyphen/</a>).

=== BaseHyphenator ===

Diese Klasse funktioniert mit jeder Sprache.
Getrennt wird nur nach den folgenden Zeichen:

{{{
    '-'   Minuszeichen (45, '\x2D')
    '.'   Punkt (46, '\x2E') (aber z.B. nicht bei Punkten zwischen Ziffern)
    '_'   Unterstrich (95, '\x5F')
    '­'   SHY hyphenation character (173, '\xAD')
}}}


== Anmerkungen ==

=== Performance ===

Der DCWHyphenator benötigt aufgrund des verwendeten
(im Prinzip rekursiven) Algorithmus relativ lange für die
Trennung eines Wortes.

Da die Wortlänge in der Praxis begrenzt ist, ergibt sich beim
Einsatz mit ReportLab eine Laufzeit proportional zur Anzahl
der (Zeilen minus Absätze), denn es wird jeweils das letzte Wort
einer Zeile geprüft (außer bei der letzten Zeile im Absatz).

Speziell für den DCWHyphenator bietet es sich an, diesen nicht direkt
zu verwenden, sondern die Ergebnisse wie folgt zu cachen:
{{{
import wordaxe
from wordaxe.DCWHyphenator import DCWHyphenator
hyph = DCWHyphenator("DE")
wordaxe.hyphRegistry ["DE"] = wordaxe.Cached(hyph, 1000)
}}}

=== Erweiterungsmöglichkeiten ===

Andere Silbentrennungsbibliotheken, z.B. von Duden,
können mit Hilfe von ctypes oder mit SWIG leicht eingebaut werden.

Dazu muss die Member-Funktion "hyphenate" überschrieben werden,
die ein Unicode-Wort als Eingabe erhält und eine HyphenatedWord-Instanz
zurückliefern muss.

=== Hinweise zu ReportLab ===

ReportLab macht uns das Leben nicht leicht, da platypus.paragraph.py
nicht gerade mit Rücksicht auf spätere Erweiterungen geschrieben wurde.

Alles wäre <em>viel</em> einfacher, wenn anstelle der vielen internen
Routinen (z.B. "_leftDrawParaLine" etc.) Methoden in der Paragraph-Klasse
verwendet würden. Eine Erweiterung der Funktionalität könnte dann
im Grunde durch einfaches Schreiben einer abgeleiteten Klasse erfolgen,
bei der im Wesentlichen nur "breakLines" überschrieben werden müsste.

Das zweite Problem bei ReportLab 2.x ist die nicht durchgängige Verwendung
von Unicode. Stattdessen wird mal mit Unicode, mal mit UTF8 und mal mit
noch anderen Byte-Codierungen gearbeitet.

=== Was noch zu tun ist ===

1. Eigene Paragraph Implementierung.

2. Spagetti-Code aufräumen, Performance-Tuning, 

...